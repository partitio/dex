// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: config.proto

/*
Package ldapaggregator is a generated protocol buffer package.

It is generated from these files:
	config.proto
	service.proto

It has these top-level messages:
	LdapConfig
	UserSearch
	GroupSearch
	ListRequest
	ListResponse
	CreateRequest
	CreateResponse
	ReadRequest
	ReadResponse
	UpdateRequest
	UpdateResponse
	DeleteRequest
	DeleteResponse
*/
package ldapaggregator

import context "context"
import strings "strings"

import errors1 "github.com/partitio/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/partitio/atlas-app-toolkit/gorm"

import fmt "fmt"
import math "math"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type LdapConfigORM struct {
	BindDN             string
	BindPW             []byte
	ClientCert         string
	ClientKey          string
	GroupSearch        *GroupSearchORM `gorm:"embedded;embedded_prefix:group_search_"`
	Host               string
	Id                 string
	InsecureNoSSL      bool
	InsecureSkipVerify bool
	Organization       string
	RootCA             string
	RootCAData         []byte
	StartTLS           bool
	UserSearch         *UserSearchORM `gorm:"embedded;embedded_prefix:user_search_"`
	UsernamePrompt     string
}

var (
	LdapConfigBindDNField             = "BindDN"
	LdapConfigBindPWField             = "BindPW"
	LdapConfigClientCertField         = "ClientCert"
	LdapConfigClientKeyField          = "ClientKey"
	LdapConfigGroupSearchField        = "GroupSearch"
	LdapConfigHostField               = "Host"
	LdapConfigIdField                 = "Id"
	LdapConfigInsecureNoSSLField      = "InsecureNoSSL"
	LdapConfigInsecureSkipVerifyField = "InsecureSkipVerify"
	LdapConfigOrganizationField       = "Organization"
	LdapConfigRootCAField             = "RootCA"
	LdapConfigRootCADataField         = "RootCAData"
	LdapConfigStartTLSField           = "StartTLS"
	LdapConfigUserSearchField         = "UserSearch"
	LdapConfigUsernamePromptField     = "UsernamePrompt"
)

// TableName overrides the default tablename generated by GORM
func (LdapConfigORM) TableName() string {
	return "ldap_configs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LdapConfig) ToORM(ctx context.Context) (LdapConfigORM, error) {
	to := LdapConfigORM{}
	var err error
	if prehook, ok := interface{}(m).(LdapConfigWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Host = m.Host
	to.InsecureNoSSL = m.InsecureNoSSL
	to.InsecureSkipVerify = m.InsecureSkipVerify
	to.StartTLS = m.StartTLS
	to.RootCA = m.RootCA
	to.ClientCert = m.ClientCert
	to.ClientKey = m.ClientKey
	to.RootCAData = m.RootCAData
	to.BindDN = m.BindDN
	to.UsernamePrompt = m.UsernamePrompt
	to.Organization = m.Organization
	if m.GetUserSearch() != nil {
		tempUserSearch, err := m.GetUserSearch().ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.UserSearch = &tempUserSearch
	}
	if m.GetGroupSearch() != nil {
		tempGroupSearch, err := m.GetGroupSearch().ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.GroupSearch = &tempGroupSearch
	}
	if posthook, ok := interface{}(m).(LdapConfigWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LdapConfigORM) ToPB(ctx context.Context) (LdapConfig, error) {
	to := LdapConfig{}
	var err error
	if prehook, ok := interface{}(m).(LdapConfigWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Host = m.Host
	to.InsecureNoSSL = m.InsecureNoSSL
	to.InsecureSkipVerify = m.InsecureSkipVerify
	to.StartTLS = m.StartTLS
	to.RootCA = m.RootCA
	to.ClientCert = m.ClientCert
	to.ClientKey = m.ClientKey
	to.RootCAData = m.RootCAData
	to.BindDN = m.BindDN
	to.UsernamePrompt = m.UsernamePrompt
	to.Organization = m.Organization
	if m.UserSearch != nil {
		tempUserSearch, err := m.UserSearch.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.UserSearch = &tempUserSearch
	}
	if m.GroupSearch != nil {
		tempGroupSearch, err := m.GroupSearch.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.GroupSearch = &tempGroupSearch
	}
	if posthook, ok := interface{}(m).(LdapConfigWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LdapConfig the arg will be the target, the caller the one being converted from

// LdapConfigBeforeToORM called before default ToORM code
type LdapConfigWithBeforeToORM interface {
	BeforeToORM(context.Context, *LdapConfigORM) error
}

// LdapConfigAfterToORM called after default ToORM code
type LdapConfigWithAfterToORM interface {
	AfterToORM(context.Context, *LdapConfigORM) error
}

// LdapConfigBeforeToPB called before default ToPB code
type LdapConfigWithBeforeToPB interface {
	BeforeToPB(context.Context, *LdapConfig) error
}

// LdapConfigAfterToPB called after default ToPB code
type LdapConfigWithAfterToPB interface {
	AfterToPB(context.Context, *LdapConfig) error
}

type UserSearchORM struct {
	BaseDN      string
	EmailAttr   string
	EmailSuffix string
	Filter      string
	IdAttr      string
	NameAttr    string
	Scope       string
	Username    string
}

var (
	UserSearchBaseDNField      = "BaseDN"
	UserSearchEmailAttrField   = "EmailAttr"
	UserSearchEmailSuffixField = "EmailSuffix"
	UserSearchFilterField      = "Filter"
	UserSearchIdAttrField      = "IdAttr"
	UserSearchNameAttrField    = "NameAttr"
	UserSearchScopeField       = "Scope"
	UserSearchUsernameField    = "Username"
)

// TableName overrides the default tablename generated by GORM
func (UserSearchORM) TableName() string {
	return "user_searches"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserSearch) ToORM(ctx context.Context) (UserSearchORM, error) {
	to := UserSearchORM{}
	var err error
	if prehook, ok := interface{}(m).(UserSearchWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BaseDN = m.BaseDN
	to.Filter = m.Filter
	to.Username = m.Username
	to.Scope = m.Scope
	to.IdAttr = m.IdAttr
	to.EmailAttr = m.EmailAttr
	to.NameAttr = m.NameAttr
	to.EmailSuffix = m.EmailSuffix
	if posthook, ok := interface{}(m).(UserSearchWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserSearchORM) ToPB(ctx context.Context) (UserSearch, error) {
	to := UserSearch{}
	var err error
	if prehook, ok := interface{}(m).(UserSearchWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BaseDN = m.BaseDN
	to.Filter = m.Filter
	to.Username = m.Username
	to.Scope = m.Scope
	to.IdAttr = m.IdAttr
	to.EmailAttr = m.EmailAttr
	to.NameAttr = m.NameAttr
	to.EmailSuffix = m.EmailSuffix
	if posthook, ok := interface{}(m).(UserSearchWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserSearch the arg will be the target, the caller the one being converted from

// UserSearchBeforeToORM called before default ToORM code
type UserSearchWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserSearchORM) error
}

// UserSearchAfterToORM called after default ToORM code
type UserSearchWithAfterToORM interface {
	AfterToORM(context.Context, *UserSearchORM) error
}

// UserSearchBeforeToPB called before default ToPB code
type UserSearchWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserSearch) error
}

// UserSearchAfterToPB called after default ToPB code
type UserSearchWithAfterToPB interface {
	AfterToPB(context.Context, *UserSearch) error
}

type GroupSearchORM struct {
	BaseDN    string
	Filter    string
	GroupAttr string
	NameAttr  string
	Scope     string
	UserAttr  string
}

var (
	GroupSearchBaseDNField    = "BaseDN"
	GroupSearchFilterField    = "Filter"
	GroupSearchGroupAttrField = "GroupAttr"
	GroupSearchNameAttrField  = "NameAttr"
	GroupSearchScopeField     = "Scope"
	GroupSearchUserAttrField  = "UserAttr"
)

// TableName overrides the default tablename generated by GORM
func (GroupSearchORM) TableName() string {
	return "group_searches"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *GroupSearch) ToORM(ctx context.Context) (GroupSearchORM, error) {
	to := GroupSearchORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupSearchWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BaseDN = m.BaseDN
	to.Filter = m.Filter
	to.Scope = m.Scope
	to.UserAttr = m.UserAttr
	to.GroupAttr = m.GroupAttr
	to.NameAttr = m.NameAttr
	if posthook, ok := interface{}(m).(GroupSearchWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupSearchORM) ToPB(ctx context.Context) (GroupSearch, error) {
	to := GroupSearch{}
	var err error
	if prehook, ok := interface{}(m).(GroupSearchWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BaseDN = m.BaseDN
	to.Filter = m.Filter
	to.Scope = m.Scope
	to.UserAttr = m.UserAttr
	to.GroupAttr = m.GroupAttr
	to.NameAttr = m.NameAttr
	if posthook, ok := interface{}(m).(GroupSearchWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type GroupSearch the arg will be the target, the caller the one being converted from

// GroupSearchBeforeToORM called before default ToORM code
type GroupSearchWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupSearchORM) error
}

// GroupSearchAfterToORM called after default ToORM code
type GroupSearchWithAfterToORM interface {
	AfterToORM(context.Context, *GroupSearchORM) error
}

// GroupSearchBeforeToPB called before default ToPB code
type GroupSearchWithBeforeToPB interface {
	BeforeToPB(context.Context, *GroupSearch) error
}

// GroupSearchAfterToPB called after default ToPB code
type GroupSearchWithAfterToPB interface {
	AfterToPB(context.Context, *GroupSearch) error
}

// DefaultCreateLdapConfig executes a basic gorm create call
func DefaultCreateLdapConfig(ctx context.Context, in *LdapConfig, db *gorm1.DB) (*LdapConfig, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LdapConfigORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadLdapConfig executes a basic gorm read call
func DefaultReadLdapConfig(ctx context.Context, in *LdapConfig, db *gorm1.DB) (*LdapConfig, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &LdapConfigORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LdapConfigORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LdapConfigORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LdapConfigORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteLdapConfig(ctx context.Context, in *LdapConfig, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LdapConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LdapConfigORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteLdapConfigSet(ctx context.Context, in []*LdapConfig, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LdapConfigORM{})).(LdapConfigORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LdapConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LdapConfigORM{})).(LdapConfigORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LdapConfigORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LdapConfig, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LdapConfig, *gorm1.DB) error
}

// DefaultStrictUpdateLdapConfig clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLdapConfig(ctx context.Context, in *LdapConfig, db *gorm1.DB) (*LdapConfig, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLdapConfig")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LdapConfigORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LdapConfigORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchLdapConfig executes a basic gorm update call with patch behavior
func DefaultPatchLdapConfig(ctx context.Context, in *LdapConfig, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*LdapConfig, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj LdapConfig
	var err error
	if hook, ok := interface{}(&pbObj).(LdapConfigWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLdapConfig(ctx, &LdapConfig{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LdapConfigWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLdapConfig(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LdapConfigWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLdapConfig(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LdapConfigWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LdapConfigWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LdapConfig, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LdapConfig, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LdapConfig, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LdapConfig, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskLdapConfig patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLdapConfig(ctx context.Context, patchee *LdapConfig, patcher *LdapConfig, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*LdapConfig, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedUserSearch bool
	var updatedGroupSearch bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Host" {
			patchee.Host = patcher.Host
			continue
		}
		if f == prefix+"InsecureNoSSL" {
			patchee.InsecureNoSSL = patcher.InsecureNoSSL
			continue
		}
		if f == prefix+"InsecureSkipVerify" {
			patchee.InsecureSkipVerify = patcher.InsecureSkipVerify
			continue
		}
		if f == prefix+"StartTLS" {
			patchee.StartTLS = patcher.StartTLS
			continue
		}
		if f == prefix+"RootCA" {
			patchee.RootCA = patcher.RootCA
			continue
		}
		if f == prefix+"ClientCert" {
			patchee.ClientCert = patcher.ClientCert
			continue
		}
		if f == prefix+"ClientKey" {
			patchee.ClientKey = patcher.ClientKey
			continue
		}
		if f == prefix+"RootCAData" {
			patchee.RootCAData = patcher.RootCAData
			continue
		}
		if f == prefix+"BindDN" {
			patchee.BindDN = patcher.BindDN
			continue
		}
		if f == prefix+"BindPW" {
			patchee.BindPW = patcher.BindPW
			continue
		}
		if f == prefix+"UsernamePrompt" {
			patchee.UsernamePrompt = patcher.UsernamePrompt
			continue
		}
		if f == prefix+"Organization" {
			patchee.Organization = patcher.Organization
			continue
		}
		if !updatedUserSearch && strings.HasPrefix(f, prefix+"UserSearch.") {
			updatedUserSearch = true
			if patcher.UserSearch == nil {
				patchee.UserSearch = nil
				continue
			}
			if patchee.UserSearch == nil {
				patchee.UserSearch = &UserSearch{}
			}
			if o, err := DefaultApplyFieldMaskUserSearch(ctx, patchee.UserSearch, patcher.UserSearch, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"UserSearch.", db); err != nil {
				return nil, err
			} else {
				patchee.UserSearch = o
			}
			continue
		}
		if f == prefix+"UserSearch" {
			updatedUserSearch = true
			patchee.UserSearch = patcher.UserSearch
			continue
		}
		if !updatedGroupSearch && strings.HasPrefix(f, prefix+"GroupSearch.") {
			updatedGroupSearch = true
			if patcher.GroupSearch == nil {
				patchee.GroupSearch = nil
				continue
			}
			if patchee.GroupSearch == nil {
				patchee.GroupSearch = &GroupSearch{}
			}
			if o, err := DefaultApplyFieldMaskGroupSearch(ctx, patchee.GroupSearch, patcher.GroupSearch, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"GroupSearch.", db); err != nil {
				return nil, err
			} else {
				patchee.GroupSearch = o
			}
			continue
		}
		if f == prefix+"GroupSearch" {
			updatedGroupSearch = true
			patchee.GroupSearch = patcher.GroupSearch
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLdapConfig executes a gorm list call
func DefaultListLdapConfig(ctx context.Context, db *gorm1.DB) ([]*LdapConfig, error) {
	in := LdapConfig{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &LdapConfigORM{}, &LdapConfig{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LdapConfigORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LdapConfigORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LdapConfig{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LdapConfigORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LdapConfigORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]LdapConfigORM) error
}

// DefaultCreateUserSearch executes a basic gorm create call
func DefaultCreateUserSearch(ctx context.Context, in *UserSearch, db *gorm1.DB) (*UserSearch, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSearchORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSearchORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserSearchORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserSearchORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskUserSearch patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserSearch(ctx context.Context, patchee *UserSearch, patcher *UserSearch, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*UserSearch, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"BaseDN" {
			patchee.BaseDN = patcher.BaseDN
			continue
		}
		if f == prefix+"Filter" {
			patchee.Filter = patcher.Filter
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Scope" {
			patchee.Scope = patcher.Scope
			continue
		}
		if f == prefix+"IdAttr" {
			patchee.IdAttr = patcher.IdAttr
			continue
		}
		if f == prefix+"EmailAttr" {
			patchee.EmailAttr = patcher.EmailAttr
			continue
		}
		if f == prefix+"NameAttr" {
			patchee.NameAttr = patcher.NameAttr
			continue
		}
		if f == prefix+"EmailSuffix" {
			patchee.EmailSuffix = patcher.EmailSuffix
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserSearch executes a gorm list call
func DefaultListUserSearch(ctx context.Context, db *gorm1.DB) ([]*UserSearch, error) {
	in := UserSearch{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSearchORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &UserSearchORM{}, &UserSearch{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSearchORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []UserSearchORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSearchORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserSearch{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserSearchORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserSearchORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserSearchORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]UserSearchORM) error
}

// DefaultCreateGroupSearch executes a basic gorm create call
func DefaultCreateGroupSearch(ctx context.Context, in *GroupSearch, db *gorm1.DB) (*GroupSearch, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSearchORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSearchORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupSearchORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupSearchORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskGroupSearch patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroupSearch(ctx context.Context, patchee *GroupSearch, patcher *GroupSearch, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*GroupSearch, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"BaseDN" {
			patchee.BaseDN = patcher.BaseDN
			continue
		}
		if f == prefix+"Filter" {
			patchee.Filter = patcher.Filter
			continue
		}
		if f == prefix+"Scope" {
			patchee.Scope = patcher.Scope
			continue
		}
		if f == prefix+"UserAttr" {
			patchee.UserAttr = patcher.UserAttr
			continue
		}
		if f == prefix+"GroupAttr" {
			patchee.GroupAttr = patcher.GroupAttr
			continue
		}
		if f == prefix+"NameAttr" {
			patchee.NameAttr = patcher.NameAttr
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroupSearch executes a gorm list call
func DefaultListGroupSearch(ctx context.Context, db *gorm1.DB) ([]*GroupSearch, error) {
	in := GroupSearch{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSearchORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &GroupSearchORM{}, &GroupSearch{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSearchORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []GroupSearchORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSearchORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*GroupSearch{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupSearchORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupSearchORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupSearchORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]GroupSearchORM) error
}
