// Code generated by protoc-gen-go. DO NOT EDIT.
// source: config.proto

package ldapaggregator

import (
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/infobloxopen/protoc-gen-gorm/options"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LdapConfig struct {
	// The id is the host ...
	Id string `protobuf:"bytes,14,opt,name=id,proto3" json:"id,omitempty"`
	// The host and optional port of the LDAP server. If port isn't supplied, it will be
	// guessed based on the TLS configuration. 389 or 636.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Required if LDAP host does not use TLS.
	InsecureNoSSL bool `protobuf:"varint,2,opt,name=insecureNoSSL,proto3" json:"insecureNoSSL,omitempty"`
	// Don't verify the CA.
	InsecureSkipVerify bool `protobuf:"varint,3,opt,name=insecureSkipVerify,proto3" json:"insecureSkipVerify,omitempty"`
	// Connect to the insecure port then issue a StartTLS command to negotiate a
	// secure connection. If unsupplied secure connections will use the LDAPS
	// protocol.
	StartTLS bool `protobuf:"varint,4,opt,name=startTLS,proto3" json:"startTLS,omitempty"`
	// Trusted root certificate file.
	RootCA string `protobuf:"bytes,5,opt,name=rootCA,proto3" json:"rootCA,omitempty"`
	// Path to a client cert file generated by rootCA.
	ClientCert string `protobuf:"bytes,6,opt,name=clientCert,proto3" json:"clientCert,omitempty"`
	// Path to a client private key file generated by rootCA.
	ClientKey string `protobuf:"bytes,7,opt,name=clientKey,proto3" json:"clientKey,omitempty"`
	// Base64 encoded PEM data containing root CAs.
	RootCAData []byte `protobuf:"bytes,8,opt,name=rootCAData,proto3" json:"rootCAData,omitempty"`
	// BindDN and BindPW for an application service account. The connector uses these
	// credentials to search for users and groups.
	BindDN string `protobuf:"bytes,9,opt,name=bindDN,proto3" json:"bindDN,omitempty"`
	BindPW string `protobuf:"bytes,10,opt,name=bindPW,proto3" json:"bindPW,omitempty"`
	// UsernamePrompt allows users to override the username attribute (displayed
	// in the username/password prompt). If unset, the handler will use
	// "Username".
	UsernamePrompt       string       `protobuf:"bytes,11,opt,name=usernamePrompt,proto3" json:"usernamePrompt,omitempty"`
	UserSearch           *UserSearch  `protobuf:"bytes,12,opt,name=userSearch,proto3" json:"userSearch,omitempty"`
	GroupSearch          *GroupSearch `protobuf:"bytes,13,opt,name=groupSearch,proto3" json:"groupSearch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LdapConfig) Reset()         { *m = LdapConfig{} }
func (m *LdapConfig) String() string { return proto.CompactTextString(m) }
func (*LdapConfig) ProtoMessage()    {}
func (*LdapConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3eaf2c85e69e9ea4, []int{0}
}

func (m *LdapConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LdapConfig.Unmarshal(m, b)
}
func (m *LdapConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LdapConfig.Marshal(b, m, deterministic)
}
func (m *LdapConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LdapConfig.Merge(m, src)
}
func (m *LdapConfig) XXX_Size() int {
	return xxx_messageInfo_LdapConfig.Size(m)
}
func (m *LdapConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LdapConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LdapConfig proto.InternalMessageInfo

func (m *LdapConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LdapConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *LdapConfig) GetInsecureNoSSL() bool {
	if m != nil {
		return m.InsecureNoSSL
	}
	return false
}

func (m *LdapConfig) GetInsecureSkipVerify() bool {
	if m != nil {
		return m.InsecureSkipVerify
	}
	return false
}

func (m *LdapConfig) GetStartTLS() bool {
	if m != nil {
		return m.StartTLS
	}
	return false
}

func (m *LdapConfig) GetRootCA() string {
	if m != nil {
		return m.RootCA
	}
	return ""
}

func (m *LdapConfig) GetClientCert() string {
	if m != nil {
		return m.ClientCert
	}
	return ""
}

func (m *LdapConfig) GetClientKey() string {
	if m != nil {
		return m.ClientKey
	}
	return ""
}

func (m *LdapConfig) GetRootCAData() []byte {
	if m != nil {
		return m.RootCAData
	}
	return nil
}

func (m *LdapConfig) GetBindDN() string {
	if m != nil {
		return m.BindDN
	}
	return ""
}

func (m *LdapConfig) GetBindPW() string {
	if m != nil {
		return m.BindPW
	}
	return ""
}

func (m *LdapConfig) GetUsernamePrompt() string {
	if m != nil {
		return m.UsernamePrompt
	}
	return ""
}

func (m *LdapConfig) GetUserSearch() *UserSearch {
	if m != nil {
		return m.UserSearch
	}
	return nil
}

func (m *LdapConfig) GetGroupSearch() *GroupSearch {
	if m != nil {
		return m.GroupSearch
	}
	return nil
}

// User entry search configuration.
type UserSearch struct {
	// BaseDN to start the search from. For example "cn=users,dc=example,dc=com"
	BaseDN string `protobuf:"bytes,1,opt,name=baseDN,proto3" json:"baseDN,omitempty"`
	// Optional filter to apply when searching the directory. For example "(objectClass=person)"
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Attribute to match against the inputted username. This will be translated and combined
	// with the other filter as "(<attr>=<username>)".
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// Can either be:
	// * "sub" - search the whole sub tree
	// * "one" - only search one level
	Scope string `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	// A mapping of attributes on the user entry to claims.
	IdAttr    string `protobuf:"bytes,5,opt,name=idAttr,proto3" json:"idAttr,omitempty"`
	EmailAttr string `protobuf:"bytes,6,opt,name=emailAttr,proto3" json:"emailAttr,omitempty"`
	NameAttr  string `protobuf:"bytes,7,opt,name=nameAttr,proto3" json:"nameAttr,omitempty"`
	// If this is set, the email claim of the id token will be constructed from the idAttr and
	// value of emailSuffix. This should not include the @ character.
	EmailSuffix          string   `protobuf:"bytes,8,opt,name=emailSuffix,proto3" json:"emailSuffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSearch) Reset()         { *m = UserSearch{} }
func (m *UserSearch) String() string { return proto.CompactTextString(m) }
func (*UserSearch) ProtoMessage()    {}
func (*UserSearch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3eaf2c85e69e9ea4, []int{1}
}

func (m *UserSearch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserSearch.Unmarshal(m, b)
}
func (m *UserSearch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserSearch.Marshal(b, m, deterministic)
}
func (m *UserSearch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSearch.Merge(m, src)
}
func (m *UserSearch) XXX_Size() int {
	return xxx_messageInfo_UserSearch.Size(m)
}
func (m *UserSearch) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSearch.DiscardUnknown(m)
}

var xxx_messageInfo_UserSearch proto.InternalMessageInfo

func (m *UserSearch) GetBaseDN() string {
	if m != nil {
		return m.BaseDN
	}
	return ""
}

func (m *UserSearch) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *UserSearch) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserSearch) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *UserSearch) GetIdAttr() string {
	if m != nil {
		return m.IdAttr
	}
	return ""
}

func (m *UserSearch) GetEmailAttr() string {
	if m != nil {
		return m.EmailAttr
	}
	return ""
}

func (m *UserSearch) GetNameAttr() string {
	if m != nil {
		return m.NameAttr
	}
	return ""
}

func (m *UserSearch) GetEmailSuffix() string {
	if m != nil {
		return m.EmailSuffix
	}
	return ""
}

// Group search configuration.
type GroupSearch struct {
	// BaseDN to start the search from. For example "cn=groups,dc=example,dc=com"
	BaseDN string `protobuf:"bytes,1,opt,name=baseDN,proto3" json:"baseDN,omitempty"`
	// Optional filter to apply when searching the directory. For example "(objectClass=posixGroup)"
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	Scope  string `protobuf:"bytes,3,opt,name=scope,proto3" json:"scope,omitempty"`
	// These two fields are use to match a user to a group.
	//
	// It adds an additional requirement to the filter that an attribute in the group
	// match the user's attribute value. For example that the "members" attribute of
	// a group matches the "uid" of the user. The exact filter being added is:
	//
	//   (<groupAttr>=<userAttr value>)
	//
	UserAttr  string `protobuf:"bytes,4,opt,name=userAttr,proto3" json:"userAttr,omitempty"`
	GroupAttr string `protobuf:"bytes,5,opt,name=groupAttr,proto3" json:"groupAttr,omitempty"`
	// The attribute of the group that represents its name.
	NameAttr             string   `protobuf:"bytes,6,opt,name=nameAttr,proto3" json:"nameAttr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GroupSearch) Reset()         { *m = GroupSearch{} }
func (m *GroupSearch) String() string { return proto.CompactTextString(m) }
func (*GroupSearch) ProtoMessage()    {}
func (*GroupSearch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3eaf2c85e69e9ea4, []int{2}
}

func (m *GroupSearch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GroupSearch.Unmarshal(m, b)
}
func (m *GroupSearch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GroupSearch.Marshal(b, m, deterministic)
}
func (m *GroupSearch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupSearch.Merge(m, src)
}
func (m *GroupSearch) XXX_Size() int {
	return xxx_messageInfo_GroupSearch.Size(m)
}
func (m *GroupSearch) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupSearch.DiscardUnknown(m)
}

var xxx_messageInfo_GroupSearch proto.InternalMessageInfo

func (m *GroupSearch) GetBaseDN() string {
	if m != nil {
		return m.BaseDN
	}
	return ""
}

func (m *GroupSearch) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *GroupSearch) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *GroupSearch) GetUserAttr() string {
	if m != nil {
		return m.UserAttr
	}
	return ""
}

func (m *GroupSearch) GetGroupAttr() string {
	if m != nil {
		return m.GroupAttr
	}
	return ""
}

func (m *GroupSearch) GetNameAttr() string {
	if m != nil {
		return m.NameAttr
	}
	return ""
}

func init() {
	proto.RegisterType((*LdapConfig)(nil), "ldap_aggregator.LdapConfig")
	proto.RegisterType((*UserSearch)(nil), "ldap_aggregator.UserSearch")
	proto.RegisterType((*GroupSearch)(nil), "ldap_aggregator.GroupSearch")
}

func init() { proto.RegisterFile("config.proto", fileDescriptor_3eaf2c85e69e9ea4) }

var fileDescriptor_3eaf2c85e69e9ea4 = []byte{
	// 642 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x4f, 0x6f, 0x12, 0x4f,
	0x18, 0xfe, 0xcd, 0x42, 0xf7, 0xc7, 0xbe, 0x50, 0x4a, 0x46, 0x63, 0x07, 0x6c, 0x0c, 0x36, 0xc6,
	0xe2, 0x01, 0x48, 0xf4, 0xd6, 0x5b, 0x69, 0x13, 0x0f, 0x36, 0x4d, 0xb3, 0xa8, 0x4d, 0x34, 0xa6,
	0x1d, 0xd8, 0x61, 0x99, 0x0a, 0x3b, 0x9b, 0xd9, 0xc1, 0xb4, 0x1e, 0x3d, 0xf6, 0x1b, 0xc1, 0xc9,
	0x93, 0xdf, 0xc5, 0x2f, 0xe0, 0xd9, 0xcc, 0xbb, 0xc0, 0x6e, 0xab, 0xa6, 0xb7, 0x7d, 0x9f, 0xe7,
	0x99, 0xf7, 0xcf, 0xc3, 0x13, 0xa0, 0x32, 0x54, 0xd1, 0x48, 0x86, 0x9d, 0x58, 0x2b, 0xa3, 0xe8,
	0xd6, 0x24, 0xe0, 0xf1, 0x39, 0x0f, 0x43, 0x2d, 0x42, 0x6e, 0x94, 0x6e, 0xec, 0x87, 0xd2, 0x8c,
	0x67, 0x83, 0xce, 0x50, 0x4d, 0xbb, 0x32, 0x1a, 0xa9, 0xc1, 0x44, 0x5d, 0xa9, 0x58, 0x44, 0x5d,
	0xd4, 0x0f, 0xdb, 0xa1, 0x88, 0xda, 0xa1, 0xd2, 0xd3, 0xae, 0x8a, 0x8d, 0x54, 0x51, 0xd2, 0xb5,
	0x45, 0xda, 0xac, 0xb1, 0xfd, 0x85, 0x4f, 0x64, 0xc0, 0x8d, 0xe8, 0xae, 0x3e, 0x52, 0x62, 0xf7,
	0x57, 0x11, 0xe0, 0x38, 0xe0, 0xf1, 0x21, 0x8e, 0xa6, 0x55, 0x70, 0x64, 0xc0, 0xaa, 0x4d, 0xd2,
	0xf2, 0x7c, 0x47, 0x06, 0x94, 0x42, 0x71, 0xac, 0x12, 0xc3, 0x08, 0x22, 0xf8, 0x4d, 0x9f, 0xc1,
	0xa6, 0x8c, 0x12, 0x31, 0x9c, 0x69, 0x71, 0xa2, 0xfa, 0xfd, 0x63, 0xe6, 0x34, 0x49, 0xab, 0xe4,
	0xdf, 0x06, 0x69, 0x07, 0xe8, 0x0a, 0xe8, 0x7f, 0x96, 0xf1, 0x7b, 0xa1, 0xe5, 0xe8, 0x9a, 0x15,
	0x50, 0xfa, 0x17, 0x86, 0x36, 0xa0, 0x94, 0x18, 0xae, 0xcd, 0xdb, 0xe3, 0x3e, 0x2b, 0xa2, 0x6a,
	0x5d, 0xd3, 0x47, 0xe0, 0x6a, 0xa5, 0xcc, 0xe1, 0x01, 0xdb, 0xc0, 0x3d, 0x96, 0x15, 0x7d, 0x02,
	0x30, 0x9c, 0x48, 0x11, 0x99, 0x43, 0xa1, 0x0d, 0x73, 0x91, 0xcb, 0x21, 0x74, 0x07, 0xbc, 0xb4,
	0x7a, 0x23, 0xae, 0xd9, 0xff, 0x48, 0x67, 0x80, 0x7d, 0x9d, 0xf6, 0x39, 0xe2, 0x86, 0xb3, 0x52,
	0x93, 0xb4, 0x2a, 0x7e, 0x0e, 0xa1, 0x4f, 0xc1, 0x1d, 0xc8, 0x28, 0x38, 0x3a, 0x61, 0x9e, 0x7d,
	0xda, 0xf3, 0x16, 0x3f, 0xbf, 0x17, 0x8a, 0xda, 0xa9, 0x15, 0xfc, 0x25, 0x41, 0xf7, 0x52, 0xc9,
	0xe9, 0x19, 0x03, 0x94, 0x6c, 0x2d, 0xe6, 0x75, 0xa7, 0x46, 0xee, 0x08, 0x4f, 0xcf, 0xe8, 0x73,
	0xa8, 0xce, 0x12, 0xa1, 0x23, 0x3e, 0x15, 0xa7, 0x5a, 0x4d, 0x63, 0xc3, 0xca, 0xb8, 0xce, 0x1d,
	0x94, 0x06, 0x00, 0x16, 0xe9, 0x0b, 0xae, 0x87, 0x63, 0x56, 0x69, 0x92, 0x56, 0xf9, 0xe5, 0xe3,
	0xce, 0x9d, 0x24, 0x74, 0xde, 0xad, 0x25, 0xbd, 0xbd, 0xc5, 0xbc, 0x5e, 0x87, 0xed, 0x0b, 0x72,
	0x59, 0xb1, 0x0f, 0xcf, 0x13, 0x84, 0xcf, 0xbf, 0x92, 0xf6, 0x37, 0x42, 0xda, 0x76, 0x91, 0x8d,
	0x1b, 0xe2, 0xd4, 0x88, 0x9f, 0xeb, 0x4b, 0xc7, 0x50, 0x0e, 0xb5, 0x9a, 0xc5, 0xcb, 0x31, 0x9b,
	0x38, 0x66, 0xe7, 0x8f, 0x31, 0xaf, 0x33, 0x4d, 0xaf, 0xb5, 0x98, 0xd7, 0x1b, 0xc0, 0x2e, 0xc8,
	0xe5, 0x26, 0x3e, 0xfd, 0xf7, 0xa0, 0x7c, 0xeb, 0x7d, 0xb6, 0x98, 0xd7, 0x1f, 0x96, 0x08, 0xad,
	0x81, 0xfb, 0xf1, 0xd3, 0xe0, 0xda, 0x08, 0xea, 0xf6, 0xd0, 0x91, 0xdd, 0x1b, 0x07, 0x20, 0xbb,
	0x03, 0xcd, 0xe6, 0x89, 0x38, 0x3a, 0x49, 0xa3, 0x96, 0x99, 0xed, 0xf8, 0x4b, 0xc2, 0xa6, 0x60,
	0x24, 0x27, 0x46, 0x68, 0x0c, 0x9c, 0xe7, 0x2f, 0x2b, 0x9b, 0x9c, 0x95, 0x8b, 0x98, 0x2f, 0xcf,
	0x5f, 0xd7, 0xf4, 0x05, 0x6c, 0x24, 0x43, 0x15, 0x0b, 0x8c, 0x94, 0xd7, 0x7b, 0x60, 0xbb, 0x56,
	0x75, 0xc5, 0xff, 0xcf, 0x2f, 0x24, 0xb3, 0x81, 0x5f, 0x50, 0x91, 0xf0, 0x53, 0x85, 0x6d, 0x2f,
	0x83, 0x03, 0x63, 0xf4, 0x2a, 0x64, 0x69, 0x65, 0x43, 0x24, 0xa6, 0x5c, 0x4e, 0x90, 0x4a, 0x33,
	0x96, 0x01, 0x76, 0xb8, 0x1d, 0x84, 0x64, 0x9a, 0xb0, 0x75, 0x4d, 0x9b, 0x50, 0x46, 0x61, 0x7f,
	0x36, 0x1a, 0xc9, 0x2b, 0x4c, 0x98, 0xe7, 0xe7, 0xa1, 0x7d, 0xd7, 0xe6, 0xa5, 0x44, 0x76, 0x7f,
	0x10, 0x28, 0xe7, 0xdc, 0xb6, 0xbb, 0xe4, 0xdd, 0xb8, 0xd7, 0x82, 0xf5, 0x99, 0x85, 0x7b, 0xcf,
	0x5c, 0xba, 0x85, 0x0b, 0x17, 0x33, 0xb7, 0x56, 0xa7, 0xe2, 0x8f, 0x97, 0x73, 0x21, 0x03, 0x6e,
	0x9d, 0xea, 0xde, 0x3e, 0x75, 0x75, 0x48, 0xaf, 0xf6, 0xa1, 0x6a, 0x53, 0x94, 0x85, 0x68, 0xe0,
	0xe2, 0xff, 0xcc, 0xab, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x15, 0xbe, 0xe7, 0xe1, 0xdd, 0x04,
	0x00, 0x00,
}
