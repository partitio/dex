syntax = "proto3";

package ldap_aggregator;

option go_package = "ldapaggregator";

import "github.com/infobloxopen/protoc-gen-gorm/options/gorm.proto";



message LdapConfig {
    option(gorm.opts) = {
      ormable: true,
      include: [
        {type: "[]byte", name: "BindPw"}
      ]
    };
    // The id is the host ...
    string id = 14;
    // The host and optional port of the LDAP server. If port isn't supplied, it will be
    // guessed based on the TLS configuration. 389 or 636.
    string host = 1;

    // Required if LDAP host does not use TLS.
    bool insecure_no_ssl = 2;

    // Don't verify the CA.
    bool insecure_skip_verify = 3;

    // Connect to the insecure port then issue a StartTLS command to negotiate a
    // secure connection. If unsupplied secure connections will use the LDAPS
    // protocol.
    bool start_tls = 4;

    // Trusted root certificate file.
    string root_ca = 5;

    // Path to a client cert file generated by rootCA.
    string client_cert = 6;

    // Path to a client private key file generated by rootCA.
    string client_key = 7;

    // Base64 encoded PEM data containing root CAs.
    bytes root_ca_data = 8;

    // BindDN and BindPW for an application service account. The connector uses these
    // credentials to search for users and groups.
    string bind_dn = 9;
    string bind_pw = 10 [(gorm.field).drop = true];

    // UsernamePrompt allows users to override the username attribute (displayed
    // in the username/password prompt). If unset, the handler will use
    // "Username".
    string username_prompt = 11;

	UserSearch user_search = 12 [(gorm.field).belongs_to = {}];

	GroupSearch group_search = 13 [(gorm.field).belongs_to = {}];
}

// User entry search configuration.
message UserSearch {
    option(gorm.opts) = {
      ormable: true,
      include: [
        {type: "int", name: "id", tag: {primary_key: true, auto_increment: true}}]
    };
    // BaseDN to start the search from. For example "cn=users,dc=example,dc=com"
    string base_dn = 1;

    // Optional filter to apply when searching the directory. For example "(objectClass=person)"
    string filter = 2;

    // Attribute to match against the inputted username. This will be translated and combined
    // with the other filter as "(<attr>=<username>)".
    string username = 3;

    // Can either be:
    // * "sub" - search the whole sub tree
    // * "one" - only search one level
    string scope = 4;

    // A mapping of attributes on the user entry to claims.
    string id_attr = 5; // Defaults to "uid"
    string email_attr = 6; // Defaults to "mail"
    string name_attr = 7; // No default.

    // If this is set, the email claim of the id token will be constructed from the idAttr and
    // value of emailSuffix. This should not include the @ character.
    string email_suffix = 8; // No default.
}

// Group search configuration.
message GroupSearch {
    option(gorm.opts) = {
      ormable: true,
      include: [
        {type: "int", name: "id", tag: {primary_key: true, auto_increment: true}}]
    };
    // BaseDN to start the search from. For example "cn=groups,dc=example,dc=com"
    string base_dn = 1;

    // Optional filter to apply when searching the directory. For example "(objectClass=posixGroup)"
    string filter = 2;

    string scope = 3; // Defaults to "sub"

    // These two fields are use to match a user to a group.
    //
    // It adds an additional requirement to the filter that an attribute in the group
    // match the user's attribute value. For example that the "members" attribute of
    // a group matches the "uid" of the user. The exact filter being added is:
    //
    //   (<groupAttr>=<userAttr value>)
    //
    string user_attr = 4;
    string group_attr = 5;

    // The attribute of the group that represents its name.
    string name_attr = 6;
}
